---
title: "Unit Testing in Motoko"
path: "motoko/unit-testing"
date: 2022-01-07
featuredImage: "/images/motoko-ghost.svg"
description: "Some early lessons learned from unit testing a Motoko canister"
---

import { TwitterTweetEmbed } from 'react-twitter-embed';

It's been a while since I last wrote a blog post - I've been busy growing the SDK team and working on my new [Invoice Canister](https://forum.dfinity.org/t/payments-invoice-canister-design-review/9843) project. The project ends up scaling to be pretty complex, since I want it to be able to abstract every token ledger on the IC with a single API, and so it led to a larger Motoko codebase than I've written before. As a result, that led me to want a better pattern for testing my code.

## Credit where it's due

After tweeting about my frustrations finding a viable testing pattern, [Paul Young](https://paulyoung.me/) tweeted about a old testing framework he came up with that has since been removed from the [Motoko Base Library](https://github.com/dfinity/motoko-base). 

<TwitterTweetEmbed tweetId={"1484700207342239745"} />

Paul linked to a small library called ActorSpec, which is designed to execute batches of tests, grouped by `describe` and `it` blocks, which feels fairly similar to Jest syntax.

## Setting it up

To get started, you'll need to install following the directions at https://github.com/dfinity/vessel.

### Configuring your project

You can find reference code for this next step at https://github.com/krpeacock/motoko-unit-tests. There, you will find examples of a `makefile`, the `vessel.dhall` and `package-set.dhall` files that you will need to get your test suite running.


```yaml
-- vessel.dhall
{ dependencies = [ "base", "matchers" ], compiler = Some "0.6.2" }

```

```yaml
-- package-set.dhall
let upstream =
      https://github.com/dfinity/vessel-package-set/releases/download/mo-0.6.1-20210522/package-set.dhall sha256:fb9eeec16309a7455e311f9d685f63b61e3e3df7970210272d06a3eddbc10de9

in  upstream
```

```swift
# Makefile
.PHONY: test

test:
	$(shell vessel bin)/moc -r $(shell vessel sources) -wasi-system-api test/*Test.mo

```

With those files in the root of your project, you can now run `vessel install`, and then you should be good to go with writing your tests.

## Writing tests

In my case, I have added a `Test.mo` file that contains my full suite of unit tests. By moving the core logic out of `main.mo` into the `Utils.mo` file, I can use consistent arguments in a `Types.mo` file for my canister's methods, and then test all the functional logic directly out of `Utils.mo`.

With that, I can use a nice syntax of describe function calls that pass `do {}` blocks that evaluate to true or false. We can then test the functions with various inputs against their expected outputs in under a second (depending on the extent of the functionality).

```swift
# Test.mo
import A          "../../src/invoice/Account";
import Hex        "../../src/invoice/Hex";
import U          "../../src/invoice/Utils";

import Blob       "mo:base/Blob";
import Debug      "mo:base/Debug";
import Principal  "mo:base/Principal";
import Result     "mo:base/Result";
import Text       "mo:base/Text";

import ActorSpec "./utils/ActorSpec";
type Group = ActorSpec.Group;

let assertTrue = ActorSpec.assertTrue;
let describe = ActorSpec.describe;
let it = ActorSpec.it;
let skip = ActorSpec.skip;
let pending = ActorSpec.pending;
let run = ActorSpec.run;

let testPrincipal = Principal.fromText("rrkah-fqaaa-aaaaa-aaaaq-cai");
let testCaller = Principal.fromText("ryjl3-tyaaa-aaaaa-aaaba-cai");
let defaultSubaccount = A.defaultSubaccount();
let canisterId = ?testPrincipal;

func defaultAccountBlob() : Blob {
    let decoded = Hex.decode("082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5");
    switch(decoded){
      case(#err _) {
        return Text.encodeUtf8("");
      };
      case(#ok arr) {
        return Blob.fromArray(arr);
      };
    }
};

func principalAccountBlob() : Blob {
  let decoded = Hex.decode("333ee20adc61d719820ac133d10f010e531ed8496ffcc439145b3df1982552e7");
  switch (decoded) {
    case (#err _) {
      return Text.encodeUtf8("");
    };
    case (#ok arr) {
      return Blob.fromArray(arr);
    };
  }
};

let success = run([
  describe("ICP Tests", [
    describe("Account Identifiers Utilities", [
      it("should generate a valid account identifier", do {
        let account = A.accountIdentifier(testPrincipal, defaultSubaccount);
        assertTrue(A.validateAccountIdentifier(account));
      }),
      it("should convert a principal to a subaccount", do {
        let subaccount = A.principalToSubaccount(testCaller);
        // Subaccounts should have a length of 32
        assertTrue(subaccount.size() == 32);
      }),
      it("should generate a valid default account for a caller", do {
        let subaccount = A.principalToSubaccount(testCaller);
        let accountIdentifier = A.accountIdentifier(testPrincipal, subaccount);
        assertTrue(A.validateAccountIdentifier(accountIdentifier));
      }),
      it("should convert a #text accountIdentifier to Text", do {
        let account = A.accountIdentifier(testPrincipal, defaultSubaccount);
        let textResult = U.accountIdentifierToText({
          accountIdentifier = #blob(account);
          canisterId = null;
        });
        switch (textResult){
          case (#err _) {
            assertTrue(false);
          };
          case (#ok text) {
            assertTrue(text == "082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5");
          };
        }
      }),
      it("should convert a #principal accountIdentifier to Text", do {
        let id = #principal(testCaller);
        let textResult = U.accountIdentifierToText({
          accountIdentifier = id;
          canisterId;
        });
        switch(textResult){
          case(#err _) {
            assertTrue(false);
          };
          case(#ok text) {
            let principalAccount = "333ee20adc61d719820ac133d10f010e531ed8496ffcc439145b3df1982552e7";
            assertTrue(text == principalAccount);
          };
        };
      }),
      it("should convert a #blob accountIdentifier to Text", do {
        let defaultBlob = defaultAccountBlob();
        let textResult = U.accountIdentifierToText({
          accountIdentifier = #blob(defaultBlob);
          canisterId = null;
        });
        switch (textResult){
          case (#err _) {
            assertTrue(false);
          };
          case (#ok text) {
            assertTrue(text == "082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5");
          };
        }
      }),
      it("should convert a #text accountIdentifier to Blob", do {
        let id = #text("082ecf2e3f647ac600f43f38a68342fba5b8e68b085f02592b77f39808a8d2b5");
        let blobResult = U.accountIdentifierToBlob({
          accountIdentifier = id;
          canisterId = null;
        });
        switch(blobResult){
          case(#err _) {
            assertTrue(false);
          };
          case(#ok blob) {
            let defaultBlob = defaultAccountBlob();
            assertTrue(blob == defaultBlob);
          };
        };
      }),
      it("should convert a #principal accountIdentifier to Blob", do {
        // This should return an accountIdentifier with the canister as a principal and the passed principal as the subaccount
        let id = #principal(testCaller);
        let blobResult = U.accountIdentifierToBlob({
          accountIdentifier = id;
          canisterId;
        });
        switch(blobResult){
          case(#err _) {
            assertTrue(false);
          };
          case(#ok blob) {
            let principalAccount = principalAccountBlob();
            assertTrue(blob == principalAccount);
          };
        };
      }),
      it("should convert a #blob accountIdentifier to Blob", do {
        let defaultBlob = defaultAccountBlob();
        let id = #blob(defaultBlob);
        let blobResult = U.accountIdentifierToBlob({
          accountIdentifier = id;
          canisterId = null;
        });
        switch(blobResult){
          case(#err _) {
            assertTrue(false);
          };
          case(#ok blob) {
            let defaultBlob = defaultAccountBlob();
            assertTrue(blob == defaultBlob);
          };
        }
      }),
      it("should reject an invalid account identifier", do {
        let invalidBlob = Text.encodeUtf8("not valid");
        let id = #blob(invalidBlob);
        let result = U.accountIdentifierToBlob({
          accountIdentifier = id;
          canisterId = null;
        });
        switch(result){
          case(#err _) {
            assertTrue(true);
          };
          case(#ok _) {
            assertTrue(false);
          };
        };
      }),
    ]),
    describe("Invoice Subaccount Creation", [
      it("should generate a valid invoice ID", do {
        let subaccount = U.generateInvoiceSubaccount({
          caller = testCaller;
          id = 0;
        });
        
        assertTrue(A.validateAccountIdentifier(subaccount));
      }),
    ])
  ]),
]);

if(success == false){
  Debug.trap("Tests failed");
}

```

## Some limitations
The main limits here are that unit tests will not interact with core replica features. Here is some functionality you will not be able to handle with unit tests in the current state:

* Time
* Calls for randomness
* Inter-canister calls
* Managing state
* Upgrade hooks

For this sort of functionality, I recommend writing end-to-end tests, deploying to alternate "staging" canisters before production, and automating your deployment scripts for consistency.
